"use strict";(globalThis.webpackChunkcoo_llm_docs=globalThis.webpackChunkcoo_llm_docs||[]).push([[77],{848:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>g});var i=n(8168),r=(n(6540),n(5680));const a={sidebar_position:3,tags:["developer-guide","balancer"]},l="Load Balancer",o={unversionedId:"Reference/Balancer",id:"Reference/Balancer",title:"Load Balancer",description:"The load balancer is the core intelligence of COO-LLM, responsible for selecting optimal provider and API key combinations based on performance, cost, and availability.",source:"@site/docs/Reference/Balancer.md",sourceDirName:"Reference",slug:"/Reference/Balancer",permalink:"/docs/docs/Reference/Balancer",draft:!1,editUrl:"https://github.com/your-org/coo-llm/tree/main/docs/docs/docs/Reference/Balancer.md",tags:[{label:"developer-guide",permalink:"/docs/docs/tags/developer-guide"},{label:"balancer",permalink:"/docs/docs/tags/balancer"}],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,tags:["developer-guide","balancer"]},sidebar:"tutorialSidebar",previous:{title:"API Reference",permalink:"/docs/docs/Reference/API"},next:{title:"Storage",permalink:"/docs/docs/Reference/Storage"}},s={},g=[{value:"Load Balancing Algorithms",id:"load-balancing-algorithms",level:2},{value:"Round Robin",id:"round-robin",level:3},{value:"Least Loaded",id:"least-loaded",level:3},{value:"Hybrid",id:"hybrid",level:3},{value:"Cost Optimization",id:"cost-optimization",level:2},{value:"Cost Optimization",id:"cost-optimization-1",level:3},{value:"Cost Estimation",id:"cost-estimation",level:3},{value:"Real-Time Pricing",id:"real-time-pricing",level:3},{value:"Rate Limit Management",id:"rate-limit-management",level:2},{value:"Key Rotation",id:"key-rotation",level:3},{value:"Provider Failover",id:"provider-failover",level:3},{value:"Metrics Collection",id:"metrics-collection",level:2},{value:"Usage Tracking",id:"usage-tracking",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Policy Configuration",id:"policy-configuration",level:3},{value:"Provider Limits",id:"provider-limits",level:3},{value:"Algorithm Details",id:"algorithm-details",level:2},{value:"Hybrid Scoring Implementation",id:"hybrid-scoring-implementation",level:3},{value:"Selection Process",id:"selection-process",level:3},{value:"Cost Estimation",id:"cost-estimation-1",level:3},{value:"Monitoring &amp; Observability",id:"monitoring--observability",level:2},{value:"Admin API",id:"admin-api",level:3},{value:"Prometheus Metrics",id:"prometheus-metrics",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Algorithm Selection",id:"algorithm-selection",level:3},{value:"Configuration Examples",id:"configuration-examples",level:3},{value:"Monitoring",id:"monitoring",level:3},{value:"Scaling",id:"scaling",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debug Commands",id:"debug-commands",level:3},{value:"Future Enhancements",id:"future-enhancements",level:2}],p={toc:g},y="wrapper";function m({components:e,...t}){return(0,r.yg)(y,(0,i.A)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"load-balancer"},"Load Balancer"),(0,r.yg)("p",null,"The load balancer is the core intelligence of COO-LLM, responsible for selecting optimal provider and API key combinations based on performance, cost, and availability."),(0,r.yg)("h2",{id:"load-balancing-algorithms"},"Load Balancing Algorithms"),(0,r.yg)("h3",{id:"round-robin"},"Round Robin"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Algorithm:")," ",(0,r.yg)("inlineCode",{parentName:"p"},"round_robin")),(0,r.yg)("p",null,"Distributes requests evenly across all available keys in a provider, respecting rate limits."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Use Case:")," Simple load distribution when all keys have similar performance and limits."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Algorithm:")),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Filter keys that are not at rate limit"),(0,r.yg)("li",{parentName:"ol"},"If no available keys, use all keys (allow bursting)"),(0,r.yg)("li",{parentName:"ol"},"Select key using round-robin from available keys")),(0,r.yg)("h3",{id:"least-loaded"},"Least Loaded"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Algorithm:")," ",(0,r.yg)("inlineCode",{parentName:"p"},"least_loaded")),(0,r.yg)("p",null,"Selects the key with the lowest total token usage, preferring non-rate-limited keys."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Use Case:")," Distribute load to avoid rate limits, prioritize underutilized keys."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Algorithm:")),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"First pass: Find non-rate-limited keys with lowest token usage"),(0,r.yg)("li",{parentName:"ol"},"Second pass: If no non-rate-limited keys, use any key with lowest usage"),(0,r.yg)("li",{parentName:"ol"},"Select key with minimum token usage")),(0,r.yg)("h3",{id:"hybrid"},"Hybrid"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Algorithm:")," ",(0,r.yg)("inlineCode",{parentName:"p"},"hybrid")),(0,r.yg)("p",null,"Combines multiple metrics with configurable weights for intelligent key selection."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Use Case:")," Balanced optimization of performance, cost, and reliability."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Scoring Formula:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},"score = w.req_ratio * reqUsage +\n        w.token_ratio * tokenUsage +\n        w.error_score * errorRate +\n        w.latency * avgLatency +\n        w.cost_ratio * estCost\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Where:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"reqUsage"),": Total requests processed by key (higher = more used)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"tokenUsage"),": Total tokens processed by key (higher = more used)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"errorRate"),": Error count / total requests (0-1, higher = worse)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"avgLatency"),": Average response time in milliseconds (higher = slower)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"estCost"),": Estimated cost per request in USD (higher = more expensive)")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Lower scores are better")," - algorithm selects key with minimum score."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Priority Presets:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"balanced"),": All weights = 0.2"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"cost"),": cost_ratio = 0.5, others = 0.125"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"req"),": req_ratio = 0.5, others = 0.125"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"token"),": token_ratio = 0.5, others = 0.125")),(0,r.yg)("h2",{id:"cost-optimization"},"Cost Optimization"),(0,r.yg)("h3",{id:"cost-optimization-1"},"Cost Optimization"),(0,r.yg)("p",null,"Use ",(0,r.yg)("inlineCode",{parentName:"p"},'priority: "cost"')," to prioritize cost minimization in hybrid scoring."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Algorithm:")),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Set cost_ratio = 0.5 in hybrid weights"),(0,r.yg)("li",{parentName:"ol"},"Calculate cost for each provider/key combination"),(0,r.yg)("li",{parentName:"ol"},"Include cost in overall scoring"),(0,r.yg)("li",{parentName:"ol"},"Select lowest score option")),(0,r.yg)("h3",{id:"cost-estimation"},"Cost Estimation"),(0,r.yg)("p",null,"Cost is estimated based on:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Input token cost \xd7 estimated input tokens"),(0,r.yg)("li",{parentName:"ul"},"Output token cost \xd7 estimated output tokens"),(0,r.yg)("li",{parentName:"ul"},"Historical usage patterns")),(0,r.yg)("h3",{id:"real-time-pricing"},"Real-Time Pricing"),(0,r.yg)("p",null,"Pricing data is configured per key:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},'pricing:\n  input_token_cost: 0.002    # $ per 1K tokens\n  output_token_cost: 0.01    # $ per 1K tokens\n  currency: "USD"\n')),(0,r.yg)("h2",{id:"rate-limit-management"},"Rate Limit Management"),(0,r.yg)("h3",{id:"key-rotation"},"Key Rotation"),(0,r.yg)("p",null,"Automatic key rotation when approaching limits:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Monitor Usage:")," Track requests/minute and tokens/minute per key"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Threshold Detection:")," Alert when usage > 80% of limit"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Rotation:")," Switch to alternative key"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Cooldown:")," Allow time for limits to reset")),(0,r.yg)("h3",{id:"provider-failover"},"Provider Failover"),(0,r.yg)("p",null,"When a provider is unavailable:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Mark provider as degraded"),(0,r.yg)("li",{parentName:"ol"},"Route traffic to alternative providers"),(0,r.yg)("li",{parentName:"ol"},"Gradually increase traffic as provider recovers")),(0,r.yg)("h2",{id:"metrics-collection"},"Metrics Collection"),(0,r.yg)("h3",{id:"usage-tracking"},"Usage Tracking"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Runtime Metrics:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"req"),": Requests per key"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"input_tokens"),": Input tokens per key"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"output_tokens"),": Output tokens per key"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"tokens"),": Total tokens per key"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"errors"),": Failed requests per key"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"latency"),": Average response time per key")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Storage:")," Redis/memory with TTL for sliding windows"),(0,r.yg)("h3",{id:"performance-monitoring"},"Performance Monitoring"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Collected Metrics:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Request latency percentiles"),(0,r.yg)("li",{parentName:"ul"},"Error rates by provider/key"),(0,r.yg)("li",{parentName:"ul"},"Token throughput"),(0,r.yg)("li",{parentName:"ul"},"Cost accumulation")),(0,r.yg)("h2",{id:"configuration"},"Configuration"),(0,r.yg)("h3",{id:"policy-configuration"},"Policy Configuration"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},'policy:\n  strategy: "hybrid"          # Legacy field, use algorithm\n  algorithm: "hybrid"         # round_robin, least_loaded, hybrid\n  priority: "balanced"        # balanced, cost, req, token (auto-sets weights)\n  hybrid_weights:             # Manual weights (auto-set based on priority)\n    token_ratio: 0.2          # Weight for token usage\n    req_ratio: 0.2            # Weight for request usage\n    error_score: 0.2          # Weight for error rate\n    latency: 0.2              # Weight for response time\n    cost_ratio: 0.2           # Weight for cost\n  retry:\n    max_attempts: 3           # Max retry attempts on failure\n    timeout: "30s"            # Timeout per attempt\n    interval: "1s"            # Delay between retries\n  cache:\n    enabled: true             # Enable response caching\n    ttl_seconds: 10           # Cache TTL\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Priority Options:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"balanced"),": Equal weights for all metrics (0.2 each)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"cost"),": Prioritize cost minimization (cost_ratio = 0.5, others = 0.125)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"req"),": Prioritize request distribution (req_ratio = 0.5, others = 0.125)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"token"),": Prioritize token efficiency (token_ratio = 0.5, others = 0.125)")),(0,r.yg)("h3",{id:"provider-limits"},"Provider Limits"),(0,r.yg)("p",null,"Rate limits are configured per provider in the ",(0,r.yg)("inlineCode",{parentName:"p"},"llm_providers")," section:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},'llm_providers:\n  - id: "openai-prod"\n    type: "openai"\n    api_keys: ["${OPENAI_KEY_1}"]\n    limits:\n      req_per_min: 200         # Requests per minute per key\n      tokens_per_min: 100000   # Tokens per minute per key\n')),(0,r.yg)("h2",{id:"algorithm-details"},"Algorithm Details"),(0,r.yg)("h3",{id:"hybrid-scoring-implementation"},"Hybrid Scoring Implementation"),(0,r.yg)("p",null,"The hybrid algorithm calculates scores for each available key using the ",(0,r.yg)("inlineCode",{parentName:"p"},"calculateScore")," method:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},'func (s *Selector) calculateScore(providerID string, key *config.Key, model string) float64 {\n    w := s.cfg.Policy.HybridWeights\n\n    reqUsage, _ := s.store.GetUsage(providerID, key.ID, "req")\n    tokenUsage, _ := s.store.GetUsage(providerID, key.ID, "tokens")\n    errorScore, _ := s.store.GetUsage(providerID, key.ID, "errors")\n    latency, _ := s.store.GetUsage(providerID, key.ID, "latency")\n\n    // Estimate cost (1000 tokens per request)\n    avgTokens := 1000.0\n    estimatedCost := (key.Pricing.InputTokenCost + key.Pricing.OutputTokenCost) * avgTokens / 1000\n\n    score := w.ReqRatio*reqUsage + w.TokenRatio*tokenUsage + w.ErrorScore*errorScore + w.Latency*latency + w.CostRatio*estimatedCost\n    return score\n}\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Metric Explanations:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"req_ratio"),": Distributes requests evenly across keys"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"token_ratio"),": Prevents keys from hitting token limits"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"error_score"),": Avoids unreliable keys (higher error count = higher penalty)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"latency"),": Prefers faster keys (higher latency = higher penalty)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"cost_ratio"),': Minimizes cost when priority is set to "cost"')),(0,r.yg)("h3",{id:"selection-process"},"Selection Process"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Resolve Model:")," Map model alias to provider ID using ",(0,r.yg)("inlineCode",{parentName:"li"},"model_aliases")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Get Provider Config:")," Retrieve provider configuration from ",(0,r.yg)("inlineCode",{parentName:"li"},"llm_providers")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Select Algorithm:")," Choose based on ",(0,r.yg)("inlineCode",{parentName:"li"},"policy.algorithm")," setting"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Filter Rate Limited Keys:")," Skip keys exceeding req/min or tokens/min limits"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Calculate Scores:")," For hybrid algorithm, compute weighted scores"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Select Best Key:")," Choose key with lowest score (or random for round-robin)"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Fallback:")," If no keys available, allow bursting on any key")),(0,r.yg)("h3",{id:"cost-estimation-1"},"Cost Estimation"),(0,r.yg)("p",null,"Cost is estimated using provider pricing and average token usage:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-go"},"estimatedCost := (inputCost + outputCost) * avgTokensPerRequest / 1000\n")),(0,r.yg)("p",null,"Where:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"avgTokensPerRequest = 1000")," (500 input + 500 output tokens)"),(0,r.yg)("li",{parentName:"ul"},"Costs are in USD per 1000 tokens")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example Calculation:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"OpenAI GPT-4: $0.03 input + $0.06 output = $0.09 per 1000 tokens"),(0,r.yg)("li",{parentName:"ul"},"Gemini Pro: $0.0005 input + $0.0015 output = $0.002 per 1000 tokens"),(0,r.yg)("li",{parentName:"ul"},"Hybrid scoring favors cheaper providers when ",(0,r.yg)("inlineCode",{parentName:"li"},'priority: "cost"'))),(0,r.yg)("h2",{id:"monitoring--observability"},"Monitoring & Observability"),(0,r.yg)("h3",{id:"admin-api"},"Admin API"),(0,r.yg)("p",null,"View balancer status:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"curl http://localhost:8080/admin/v1/providers\n")),(0,r.yg)("p",null,"Response includes:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Key usage statistics"),(0,r.yg)("li",{parentName:"ul"},"Error rates"),(0,r.yg)("li",{parentName:"ul"},"Performance metrics"),(0,r.yg)("li",{parentName:"ul"},"Current selection status")),(0,r.yg)("h3",{id:"prometheus-metrics"},"Prometheus Metrics"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-prometheus"},'# Request distribution\nllm_requests_total{provider="openai",key="key1"} 150\n\n# Performance metrics\nllm_request_duration_seconds{provider="openai",quantile="0.95"} 2.5\n\n# Cost tracking\nllm_cost_total{provider="openai",currency="USD"} 12.50\n')),(0,r.yg)("h2",{id:"best-practices"},"Best Practices"),(0,r.yg)("h3",{id:"algorithm-selection"},"Algorithm Selection"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Round Robin:")," Simple deployments, uniform key performance"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Least Loaded:")," High-throughput scenarios, avoid hitting limits"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Hybrid:")," Most production use cases, balanced optimization")),(0,r.yg)("h3",{id:"configuration-examples"},"Configuration Examples"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Cost-Optimized:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},'policy:\n  algorithm: "hybrid"\n  priority: "cost"\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Performance-Optimized:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},'policy:\n  algorithm: "hybrid"\n  priority: "balanced"\n  hybrid_weights:\n    latency: 0.3    # Prioritize speed\n    cost_ratio: 0.1 # Less cost focus\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"High-Reliability:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},'policy:\n  algorithm: "hybrid"\n  priority: "balanced"\n  hybrid_weights:\n    error_score: 0.3  # Strong error penalty\n')),(0,r.yg)("h3",{id:"monitoring"},"Monitoring"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Set up alerts for high error rates (>5%)"),(0,r.yg)("li",{parentName:"ul"},"Monitor cost accumulation vs. budget"),(0,r.yg)("li",{parentName:"ul"},"Track key utilization distribution (should be ~equal)"),(0,r.yg)("li",{parentName:"ul"},"Watch latency percentiles (P95 < 5s)")),(0,r.yg)("h3",{id:"scaling"},"Scaling"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Add more keys to increase throughput"),(0,r.yg)("li",{parentName:"ul"},"Use multiple providers for redundancy"),(0,r.yg)("li",{parentName:"ul"},"Monitor and adjust rate limits based on usage"),(0,r.yg)("li",{parentName:"ul"},"Consider ",(0,r.yg)("inlineCode",{parentName:"li"},"least_loaded")," for high-volume deployments")),(0,r.yg)("h2",{id:"troubleshooting"},"Troubleshooting"),(0,r.yg)("h3",{id:"common-issues"},"Common Issues"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"All keys at limit:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Increase rate limits in provider dashboard"),(0,r.yg)("li",{parentName:"ul"},"Add more API keys"),(0,r.yg)("li",{parentName:"ul"},"Implement request queuing")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"High latency:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Check provider status"),(0,r.yg)("li",{parentName:"ul"},"Switch to closer regions"),(0,r.yg)("li",{parentName:"ul"},"Optimize request batching")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Cost spikes:")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Review pricing configuration"),(0,r.yg)("li",{parentName:"ul"},"Set ",(0,r.yg)("inlineCode",{parentName:"li"},'priority: "cost"')),(0,r.yg)("li",{parentName:"ul"},"Set spending limits")),(0,r.yg)("h3",{id:"debug-commands"},"Debug Commands"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},'# View current key usage\ncurl http://localhost:8080/admin/v1/providers\n\n# Check configuration\ncurl http://localhost:8080/admin/v1/config\n\n# View recent logs\ncurl "http://localhost:8080/admin/v1/logs?limit=50"\n')),(0,r.yg)("h2",{id:"future-enhancements"},"Future Enhancements"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Machine Learning:")," Predictive key selection based on historical patterns"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Dynamic Limits:")," Adjust limits based on provider announcements"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Multi-Region:")," Geographic load balancing"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Request Batching:")," Combine multiple requests for efficiency")))}m.isMDXComponent=!0},5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>c});var i=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function o(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),g=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=g(e.components);return i.createElement(s.Provider,{value:t},e.children)},y="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef(function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),y=g(n),u=r,c=y["".concat(s,".").concat(u)]||y[u]||m[u]||a;return n?i.createElement(c,l(l({ref:t},p),{},{components:n})):i.createElement(c,l({ref:t},p))});function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[y]="string"==typeof e?e:r,l[1]=o;for(var g=2;g<a;g++)l[g]=n[g];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);