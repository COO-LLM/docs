"use strict";(globalThis.webpackChunkcoo_llm_docs=globalThis.webpackChunkcoo_llm_docs||[]).push([[3866],{6324:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Reference/Balancer","title":"Load Balancer","description":"The load balancer is the core intelligence of COO-LLM, responsible for selecting optimal provider and API key combinations based on performance, cost, and availability.","source":"@site/content/Reference/Balancer.md","sourceDirName":"Reference","slug":"/Reference/Balancer","permalink":"/docs/docs/Reference/Balancer","draft":false,"unlisted":false,"editUrl":"https://github.com/coo-llm/coo-llm-main/tree/main/docs/content/content/Reference/Balancer.md","tags":[{"inline":true,"label":"developer-guide","permalink":"/docs/docs/tags/developer-guide"},{"inline":true,"label":"balancer","permalink":"/docs/docs/tags/balancer"}],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"tags":["developer-guide","balancer"]},"sidebar":"tutorialSidebar","previous":{"title":"API Reference","permalink":"/docs/docs/Reference/API"},"next":{"title":"Storage","permalink":"/docs/docs/Reference/Storage"}}');var s=n(4848),l=n(8453);const o={sidebar_position:3,tags:["developer-guide","balancer"]},t="Load Balancer",c={},d=[{value:"Load Balancing Algorithms",id:"load-balancing-algorithms",level:2},{value:"Algorithm Overview",id:"algorithm-overview",level:3},{value:"Round Robin",id:"round-robin",level:3},{value:"Least Loaded",id:"least-loaded",level:3},{value:"Hybrid",id:"hybrid",level:3},{value:"Cost Optimization",id:"cost-optimization",level:2},{value:"Cost Optimization",id:"cost-optimization-1",level:3},{value:"Cost Estimation",id:"cost-estimation",level:3},{value:"Real-Time Pricing",id:"real-time-pricing",level:3},{value:"Rate Limit Management",id:"rate-limit-management",level:2},{value:"Key Rotation",id:"key-rotation",level:3},{value:"Provider Failover",id:"provider-failover",level:3},{value:"Metrics Collection",id:"metrics-collection",level:2},{value:"Usage Tracking",id:"usage-tracking",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Policy Configuration",id:"policy-configuration",level:3},{value:"Provider Limits",id:"provider-limits",level:3},{value:"Algorithm Details",id:"algorithm-details",level:2},{value:"Hybrid Scoring Implementation",id:"hybrid-scoring-implementation",level:3},{value:"Selection Process",id:"selection-process",level:3},{value:"Cost Estimation",id:"cost-estimation-1",level:3},{value:"Monitoring &amp; Observability",id:"monitoring--observability",level:2},{value:"Admin API",id:"admin-api",level:3},{value:"Prometheus Metrics",id:"prometheus-metrics",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Algorithm Selection",id:"algorithm-selection",level:3},{value:"Configuration Examples",id:"configuration-examples",level:3},{value:"Monitoring",id:"monitoring",level:3},{value:"Scaling",id:"scaling",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debug Commands",id:"debug-commands",level:3},{value:"Future Enhancements",id:"future-enhancements",level:2}];function a(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"load-balancer",children:"Load Balancer"})}),"\n",(0,s.jsx)(i.p,{children:"The load balancer is the core intelligence of COO-LLM, responsible for selecting optimal provider and API key combinations based on performance, cost, and availability."}),"\n",(0,s.jsx)(i.h2,{id:"load-balancing-algorithms",children:"Load Balancing Algorithms"}),"\n",(0,s.jsx)(i.h3,{id:"algorithm-overview",children:"Algorithm Overview"}),"\n",(0,s.jsx)(i.mermaid,{value:"flowchart TD\n    classDef input fill:#28a745,color:#fff,stroke:#fff,stroke-width:2px\n    classDef process fill:#dc3545,color:#fff,stroke:#fff,stroke-width:2px\n    classDef decision fill:#ffc107,color:#000,stroke:#000,stroke-width:2px\n    classDef output fill:#007bff,color:#fff,stroke:#fff,stroke-width:2px\n\n    A[Incoming Request<br/>Model: gpt-4o]:::input\n    A --\x3e B[Resolve Model Alias<br/>Map to provider:model]:::process\n    B --\x3e C[Get Available Keys<br/>Filter by provider]:::process\n    C --\x3e D{Algorithm?}:::decision\n\n    D --\x3e|Round Robin| E[Cycle through keys<br/>Respect rate limits]:::process\n    D --\x3e|Least Loaded| F[Select lowest token usage<br/>Prefer non-limited keys]:::process\n    D --\x3e|Hybrid| G[Calculate weighted score<br/>req + token + error + latency + cost]:::process\n\n    E --\x3e H[Selected Key]:::output\n    F --\x3e H\n    G --\x3e H\n\n    H --\x3e I[Execute Request<br/>With selected key]:::process"}),"\n",(0,s.jsx)(i.h3,{id:"round-robin",children:"Round Robin"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Algorithm:"})," ",(0,s.jsx)(i.code,{children:"round_robin"})]}),"\n",(0,s.jsx)(i.p,{children:"Distributes requests evenly across all available keys in a provider, respecting rate limits."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Use Case:"})," Simple load distribution when all keys have similar performance and limits."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Algorithm:"})}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Filter keys that are not at rate limit"}),"\n",(0,s.jsx)(i.li,{children:"If no available keys, use all keys (allow bursting)"}),"\n",(0,s.jsx)(i.li,{children:"Select key using round-robin from available keys"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"least-loaded",children:"Least Loaded"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Algorithm:"})," ",(0,s.jsx)(i.code,{children:"least_loaded"})]}),"\n",(0,s.jsx)(i.p,{children:"Selects the key with the lowest total token usage, preferring non-rate-limited keys."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Use Case:"})," Distribute load to avoid rate limits, prioritize underutilized keys."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Algorithm:"})}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"First pass: Find non-rate-limited keys with lowest token usage"}),"\n",(0,s.jsx)(i.li,{children:"Second pass: If no non-rate-limited keys, use any key with lowest usage"}),"\n",(0,s.jsx)(i.li,{children:"Select key with minimum token usage"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"hybrid",children:"Hybrid"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Algorithm:"})," ",(0,s.jsx)(i.code,{children:"hybrid"})]}),"\n",(0,s.jsx)(i.p,{children:"Combines multiple metrics with configurable weights for intelligent key selection."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Use Case:"})," Balanced optimization of performance, cost, and reliability."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Scoring Formula:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:"score = w.req_ratio * reqUsage +\n        w.token_ratio * tokenUsage +\n        w.error_score * errorRate +\n        w.latency * avgLatency +\n        w.cost_ratio * estCost\n"})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Where:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"reqUsage"}),": Total requests processed by key (higher = more used)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"tokenUsage"}),": Total tokens processed by key (higher = more used)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"errorRate"}),": Error count / total requests (0-1, higher = worse)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"avgLatency"}),": Average response time in milliseconds (higher = slower)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"estCost"}),": Estimated cost per request in USD (higher = more expensive)"]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Lower scores are better"})," - algorithm selects key with minimum score."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Priority Presets:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"balanced"}),": All weights = 0.2"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"cost"}),": cost_ratio = 0.5, others = 0.125"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"req"}),": req_ratio = 0.5, others = 0.125"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"token"}),": token_ratio = 0.5, others = 0.125"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"cost-optimization",children:"Cost Optimization"}),"\n",(0,s.jsx)(i.h3,{id:"cost-optimization-1",children:"Cost Optimization"}),"\n",(0,s.jsxs)(i.p,{children:["Use ",(0,s.jsx)(i.code,{children:'priority: "cost"'})," to prioritize cost minimization in hybrid scoring."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Algorithm:"})}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Set cost_ratio = 0.5 in hybrid weights"}),"\n",(0,s.jsx)(i.li,{children:"Calculate cost for each provider/key combination"}),"\n",(0,s.jsx)(i.li,{children:"Include cost in overall scoring"}),"\n",(0,s.jsx)(i.li,{children:"Select lowest score option"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"cost-estimation",children:"Cost Estimation"}),"\n",(0,s.jsx)(i.p,{children:"Cost is estimated based on:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Input token cost \xd7 estimated input tokens"}),"\n",(0,s.jsx)(i.li,{children:"Output token cost \xd7 estimated output tokens"}),"\n",(0,s.jsx)(i.li,{children:"Historical usage patterns"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"real-time-pricing",children:"Real-Time Pricing"}),"\n",(0,s.jsx)(i.p,{children:"Pricing data is configured per key:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'pricing:\n  input_token_cost: 0.002    # $ per 1K tokens\n  output_token_cost: 0.01    # $ per 1K tokens\n  currency: "USD"\n'})}),"\n",(0,s.jsx)(i.h2,{id:"rate-limit-management",children:"Rate Limit Management"}),"\n",(0,s.jsx)(i.h3,{id:"key-rotation",children:"Key Rotation"}),"\n",(0,s.jsx)(i.p,{children:"Automatic key rotation when approaching limits:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Monitor Usage:"})," Track requests/minute and tokens/minute per key"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Threshold Detection:"})," Alert when usage > 80% of limit"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Rotation:"})," Switch to alternative key"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Cooldown:"})," Allow time for limits to reset"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"provider-failover",children:"Provider Failover"}),"\n",(0,s.jsx)(i.p,{children:"When a provider is unavailable:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Mark provider as degraded"}),"\n",(0,s.jsx)(i.li,{children:"Route traffic to alternative providers"}),"\n",(0,s.jsx)(i.li,{children:"Gradually increase traffic as provider recovers"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"metrics-collection",children:"Metrics Collection"}),"\n",(0,s.jsx)(i.h3,{id:"usage-tracking",children:"Usage Tracking"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Runtime Metrics:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"req"}),": Requests per key"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"input_tokens"}),": Input tokens per key"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"output_tokens"}),": Output tokens per key"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"tokens"}),": Total tokens per key"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"errors"}),": Failed requests per key"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"latency"}),": Average response time per key"]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Storage:"})," Redis/memory with TTL for sliding windows"]}),"\n",(0,s.jsx)(i.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Collected Metrics:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Request latency percentiles"}),"\n",(0,s.jsx)(i.li,{children:"Error rates by provider/key"}),"\n",(0,s.jsx)(i.li,{children:"Token throughput"}),"\n",(0,s.jsx)(i.li,{children:"Cost accumulation"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(i.h3,{id:"policy-configuration",children:"Policy Configuration"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'policy:\n  strategy: "hybrid"          # Legacy field, use algorithm\n  algorithm: "hybrid"         # round_robin, least_loaded, hybrid\n  priority: "balanced"        # balanced, cost, req, token (auto-sets weights)\n  hybrid_weights:             # Manual weights (auto-set based on priority)\n    token_ratio: 0.2          # Weight for token usage\n    req_ratio: 0.2            # Weight for request usage\n    error_score: 0.2          # Weight for error rate\n    latency: 0.2              # Weight for response time\n    cost_ratio: 0.2           # Weight for cost\n  retry:\n    max_attempts: 3           # Max retry attempts on failure\n    timeout: "30s"            # Timeout per attempt\n    interval: "1s"            # Delay between retries\n  cache:\n    enabled: true             # Enable response caching\n    ttl_seconds: 10           # Cache TTL\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Priority Options:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"balanced"}),": Equal weights for all metrics (0.2 each)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"cost"}),": Prioritize cost minimization (cost_ratio = 0.5, others = 0.125)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"req"}),": Prioritize request distribution (req_ratio = 0.5, others = 0.125)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"token"}),": Prioritize token efficiency (token_ratio = 0.5, others = 0.125)"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"provider-limits",children:"Provider Limits"}),"\n",(0,s.jsxs)(i.p,{children:["Rate limits are configured per provider in the ",(0,s.jsx)(i.code,{children:"llm_providers"})," section:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'llm_providers:\n  - id: "openai-prod"\n    type: "openai"\n    api_keys: ["${OPENAI_KEY_1}"]\n    limits:\n      req_per_min: 200         # Requests per minute per key\n      tokens_per_min: 100000   # Tokens per minute per key\n'})}),"\n",(0,s.jsx)(i.h2,{id:"algorithm-details",children:"Algorithm Details"}),"\n",(0,s.jsx)(i.h3,{id:"hybrid-scoring-implementation",children:"Hybrid Scoring Implementation"}),"\n",(0,s.jsxs)(i.p,{children:["The hybrid algorithm calculates scores for each available key using the ",(0,s.jsx)(i.code,{children:"calculateScore"})," method:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:'func (s *Selector) calculateScore(providerID string, key *config.Key, model string) float64 {\n    w := s.cfg.Policy.HybridWeights\n\n    reqUsage, _ := s.store.GetUsage(providerID, key.ID, "req")\n    tokenUsage, _ := s.store.GetUsage(providerID, key.ID, "tokens")\n    errorScore, _ := s.store.GetUsage(providerID, key.ID, "errors")\n    latency, _ := s.store.GetUsage(providerID, key.ID, "latency")\n\n    // Estimate cost (1000 tokens per request)\n    avgTokens := 1000.0\n    estimatedCost := (key.Pricing.InputTokenCost + key.Pricing.OutputTokenCost) * avgTokens / 1000\n\n    score := w.ReqRatio*reqUsage + w.TokenRatio*tokenUsage + w.ErrorScore*errorScore + w.Latency*latency + w.CostRatio*estimatedCost\n    return score\n}\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Metric Explanations:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"req_ratio"}),": Distributes requests evenly across keys"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"token_ratio"}),": Prevents keys from hitting token limits"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"error_score"}),": Avoids unreliable keys (higher error count = higher penalty)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"latency"}),": Prefers faster keys (higher latency = higher penalty)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"cost_ratio"}),': Minimizes cost when priority is set to "cost"']}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"selection-process",children:"Selection Process"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Resolve Model:"})," Map model alias to provider ID using ",(0,s.jsx)(i.code,{children:"model_aliases"})]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Get Provider Config:"})," Retrieve provider configuration from ",(0,s.jsx)(i.code,{children:"llm_providers"})]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Select Algorithm:"})," Choose based on ",(0,s.jsx)(i.code,{children:"policy.algorithm"})," setting"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Filter Rate Limited Keys:"})," Skip keys exceeding req/min or tokens/min limits"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Calculate Scores:"})," For hybrid algorithm, compute weighted scores"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Select Best Key:"})," Choose key with lowest score (or random for round-robin)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Fallback:"})," If no keys available, allow bursting on any key"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"cost-estimation-1",children:"Cost Estimation"}),"\n",(0,s.jsx)(i.p,{children:"Cost is estimated using provider pricing and average token usage:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-go",children:"estimatedCost := (inputCost + outputCost) * avgTokensPerRequest / 1000\n"})}),"\n",(0,s.jsx)(i.p,{children:"Where:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"avgTokensPerRequest = 1000"})," (500 input + 500 output tokens)"]}),"\n",(0,s.jsx)(i.li,{children:"Costs are in USD per 1000 tokens"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example Calculation:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"OpenAI GPT-4: $0.03 input + $0.06 output = $0.09 per 1000 tokens"}),"\n",(0,s.jsx)(i.li,{children:"Gemini Pro: $0.0005 input + $0.0015 output = $0.002 per 1000 tokens"}),"\n",(0,s.jsxs)(i.li,{children:["Hybrid scoring favors cheaper providers when ",(0,s.jsx)(i.code,{children:'priority: "cost"'})]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"monitoring--observability",children:"Monitoring & Observability"}),"\n",(0,s.jsx)(i.h3,{id:"admin-api",children:"Admin API"}),"\n",(0,s.jsx)(i.p,{children:"View balancer status:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"curl http://localhost:8080/admin/v1/providers\n"})}),"\n",(0,s.jsx)(i.p,{children:"Response includes:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Key usage statistics"}),"\n",(0,s.jsx)(i.li,{children:"Error rates"}),"\n",(0,s.jsx)(i.li,{children:"Performance metrics"}),"\n",(0,s.jsx)(i.li,{children:"Current selection status"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"prometheus-metrics",children:"Prometheus Metrics"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-prometheus",children:'# Request distribution\nllm_requests_total{provider="openai",key="key1"} 150\n\n# Performance metrics\nllm_request_duration_seconds{provider="openai",quantile="0.95"} 2.5\n\n# Cost tracking\nllm_cost_total{provider="openai",currency="USD"} 12.50\n'})}),"\n",(0,s.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(i.h3,{id:"algorithm-selection",children:"Algorithm Selection"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Round Robin:"})," Simple deployments, uniform key performance"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Least Loaded:"})," High-throughput scenarios, avoid hitting limits"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Hybrid:"})," Most production use cases, balanced optimization"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Cost-Optimized:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'policy:\n  algorithm: "hybrid"\n  priority: "cost"\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Performance-Optimized:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'policy:\n  algorithm: "hybrid"\n  priority: "balanced"\n  hybrid_weights:\n    latency: 0.3    # Prioritize speed\n    cost_ratio: 0.1 # Less cost focus\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"High-Reliability:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'policy:\n  algorithm: "hybrid"\n  priority: "balanced"\n  hybrid_weights:\n    error_score: 0.3  # Strong error penalty\n'})}),"\n",(0,s.jsx)(i.h3,{id:"monitoring",children:"Monitoring"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Set up alerts for high error rates (>5%)"}),"\n",(0,s.jsx)(i.li,{children:"Monitor cost accumulation vs. budget"}),"\n",(0,s.jsx)(i.li,{children:"Track key utilization distribution (should be ~equal)"}),"\n",(0,s.jsx)(i.li,{children:"Watch latency percentiles (P95 < 5s)"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"scaling",children:"Scaling"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Add more keys to increase throughput"}),"\n",(0,s.jsx)(i.li,{children:"Use multiple providers for redundancy"}),"\n",(0,s.jsx)(i.li,{children:"Monitor and adjust rate limits based on usage"}),"\n",(0,s.jsxs)(i.li,{children:["Consider ",(0,s.jsx)(i.code,{children:"least_loaded"})," for high-volume deployments"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(i.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"All keys at limit:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Increase rate limits in provider dashboard"}),"\n",(0,s.jsx)(i.li,{children:"Add more API keys"}),"\n",(0,s.jsx)(i.li,{children:"Implement request queuing"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"High latency:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Check provider status"}),"\n",(0,s.jsx)(i.li,{children:"Switch to closer regions"}),"\n",(0,s.jsx)(i.li,{children:"Optimize request batching"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Cost spikes:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Review pricing configuration"}),"\n",(0,s.jsxs)(i.li,{children:["Set ",(0,s.jsx)(i.code,{children:'priority: "cost"'})]}),"\n",(0,s.jsx)(i.li,{children:"Set spending limits"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"debug-commands",children:"Debug Commands"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:'# View current key usage\ncurl http://localhost:8080/admin/v1/providers\n\n# Check configuration\ncurl http://localhost:8080/admin/v1/config\n\n# View recent logs\ncurl "http://localhost:8080/admin/v1/logs?limit=50"\n'})}),"\n",(0,s.jsx)(i.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Machine Learning:"})," Predictive key selection based on historical patterns"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Dynamic Limits:"})," Adjust limits based on provider announcements"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Multi-Region:"})," Geographic load balancing"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Request Batching:"})," Combine multiple requests for efficiency"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>t});var r=n(6540);const s={},l=r.createContext(s);function o(e){const i=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(l.Provider,{value:i},e.children)}}}]);